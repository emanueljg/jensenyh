/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package ons24aug;

import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.Set;
import java.util.stream.Collectors;

public class Solutions {
    private static Set<Character> consonants = 
        Set.of('b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l',
               'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'z');

    private static String consonantsStr = consonants.stream()
                                            .map(ch -> ch.toString())
                                            .collect(Collectors.joining());

    private static Pattern piratePattern = Pattern.compile(
                            String.format("([%s])o\\1", consonantsStr),
                        Pattern.CASE_INSENSITIVE
                      );

    private static Pattern calculatorPattern = Pattern.compile(" *(\\d+) *([-+*/]) *(\\d+) *");

    private static String getTimes(int... units) {
        StringBuilder returned = new StringBuilder();

        // storage for time numbers
        int[] time = new int[units.length];

        // the counter number is set to be the last (=leftmost)
        // number of the array
        // [ 24, 60, 60 <- counter ]
        int counterIdx = units.length - 1;

        while (true) {
            for (int i = 0; i < units[counterIdx]; i++) {
                // set the counter
                time[counterIdx] = i;
                
                // print out current number
                for (int j = 0; j < time.length; j++) {
                    String unitStr = String.valueOf(units[j]);
                    String timeStr = String.valueOf(time[j]);

                    returned.append("0".repeat(unitStr.length() - timeStr.length()));
                    returned.append(timeStr);
                    returned.append(j != time.length - 1 ? ":" : "");
                }
                returned.append("\n");
            }
            
            // reset the counter
            time[counterIdx] = 0;

            // start incrementing the number ("tipping over") above the counter
            int tipOverIdx = counterIdx - 1;
            while (true) {
                int tipOverValue = time[tipOverIdx];
                // check that it doesn't overflow if we were to tip it over
                if (tipOverValue + 1 < units[tipOverIdx]) {
                    // we're good to go, tip it over, break out of the tipover
                    // and start counting again
                    time[tipOverIdx] += 1;
                    break;
                } else {
                    // the tipover is already full itself
                    if (tipOverIdx - 1 >= 0) {
                        // we'd still in range if we were to tipover the index below the tipover,
                        // so let's do that. But Before that, we also need to tip over the previous value.
                        time[tipOverIdx] = 0;
                        tipOverIdx--;
                    } else {
                        // we wouldn't be in range anymore, which means we just reached the cap of our highest number
                        // time to break out of the method
                        return returned.toString();
                    }
                }
            }
        }
    }

    public static String getTheClock() {
        return getTimes(24, 60);
    }

    public static String getTheClockWithSeconds() {
        return getTimes(24, 60, 60);

    }
    
    public static String getReversed(String str) {
        StringBuilder reversed = new StringBuilder();
        for (int i = str.length() - 1; i >= 0; i--) {
            reversed.append(str.charAt(i));
        }
        return reversed.toString();
    }
    
    public static boolean isWordPalindrome(String word) {
        for (int i = 0; i < word.length(); i++) {
            char ch = Character.toLowerCase(word.charAt(i));
            char mirroredCh = Character.toLowerCase(
                                word.charAt(word.length() - 1 - i)
                                    
                              );
            if (mirroredCh != ch) { 
        return false;
            }
        }
    return true;
    }
    
    public static boolean isSentencePalindrome(String str) {
        StringBuilder letters = new StringBuilder();
        for (char ch : str.toCharArray()) {
            if (Character.isLetter(ch)) {
                letters.append(ch);
            }
        }
    return isWordPalindrome(letters.toString());
    }
    
    public static String toPirateSpeak(String str) {
        StringBuilder pirateSpeak = new StringBuilder();
        for (char ch : str.toCharArray()) {
        // doing the character cases like this solves
        // the issue of capital letters at the
        // beginning of sentences messing up
        // eg: we want
        // Joj totalolaror
        // and not
        // JoJ totalolaror 
        char loweredCh = Character.toLowerCase(ch);
            if (consonants.contains(loweredCh)) {
                pirateSpeak.append(ch);
                pirateSpeak.append('o');
                pirateSpeak.append(loweredCh);
            } else {
                pirateSpeak.append(ch);
            }
        }        
    return pirateSpeak.toString();
    }
    
    public static String fromPirateSpeak(String str) {
    return piratePattern.matcher(str).replaceAll("$1");
    }
    
    public static int parseCalculation(String str) {
        Matcher m = calculatorPattern.matcher(str);
        if (m.matches()) {
            int a = Integer.valueOf(m.group(1));
            int b = Integer.valueOf(m.group(3));  // note: no symmetry!
        
            switch (m.group(2)) {
                case "-": 
                    return a - b;
                case "+":
                    return a + b;
                case "*":
                    return a * b;
                case "/":
                    return a / b;
            }
        }
    return 0;
    }

    public static void main(String[] args) {
//        System.out.println(theClockWithSeconds());
        // theClock();
        // theClockWithSeconds();
        // reverseAString();
        // printIfWordPalindrome();
        // printIfSentencePalindrome();
        // printPirateLanguage();
        // printPirateLanguageInverse();
//        System.out.println(parseCalculation(getInput()));
    }
}
